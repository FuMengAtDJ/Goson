<html>
  <head>
    <title>JSchema-Gosu Documentation</title>
    <script type="text/javascript" src="generated_toc.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css" />
  </head>
  <body>
    <h1>Introduction</h1>
    <p>JSchema-Gosu is a Gosu implementation of the <a href="http://jschema.org">JSchema</a> and <a href="http://jschema.org">JSchema-RPC</a>
      specifications.  It consists of:</p>
    <ul>
      <li>A Typeloader For JSchema (.jsc), JSON (.json) and JSchema-RPC (.jsc-rpc) documents</li>
      <li>Tools for working with JSON</li>
      <li>A servlet filter that can be used to publish JSchema-RPC end points</li>
      <li>A simple HTTP server that can be used to publish JSchema-RPC end points</li>
    </ul>
    <p>As with other Gosu Type Loaders, you need only to add this jar to your project's classpath to start using the JSchema-based
    types.</p>

    <h1>JSchema Example</h1>
    <p>
      Let's say that you have the following <code>.jsc</code> file in your source directory at <code>src/jschema/Invoice.jsc</code>:
    </p>
    <pre>
{
  "typedefs@" : {
    "Address" : {
       "type" : { "enum" : ["business", "residential"] },
       "line1" : "string",
       "line2" : "string",
       "city" : "string",
       "state" : "string",
       "country" : "string",
       "zip" : "int"
     }
  },
  "id" : "int",
  "date" : "date",
  "billing_address" : "Address",
  "customers" : [ {
    "first_name" : "string",
    "last_name" : "string",
    "business_name" : "string",
    "address" : "Address"
   } ],
   "items" : [ {
     "name" : "string",
     "sku" : "number",
     "amount" : "number",
     "unit_cost" : "number",
     "total_cost" : "number"
   } ]
}
    </pre>
    <p>
      Given this JSchema file, the JSchema-Gosu type loader will create the following types:
    </p>
    <ul>
      <li><code>jschema.Invoice</code></li>
      <li><code>jschema.Invoice.Address</code></li>
      <li><code>jschema.Invoice.Customers</code></li>
      <li><code>jschema.Invoice.Items</code></li>
    </ul>

    <h2>Creating An Invoice</h2>
    <p>
      Creating an Invoice based on this schema in Gosu is quite simple:
    </p>
    <pre>
  uses jschema.Invoice
  
  var invoice = new Invoice() {
    :Id = 42,
    :Date = Date.Today,
    :BillingAddress = new Invoice.Address() {
      :Type = BUSINESS,
      :Line1 = "123 Main Street",
      :City = "Menlo Park",
      :State = "CA",
      :Country = "USA",
      :Zip = 12345
    },
    :Customers = {
      new Invoice.Customers() {
        :FirstName = "Ted",
        :LastName = "Smith",
        :Address = new Invoice.Address() {
          :Type = RESIDENTIAL,
          :Line1 = "1122 G Street",
          :City = "Stockton",
          :State = "CA",
          :Country = "USA",
          :Zip = 12345
        }
      }
    },
    :Items = {
      new Invoice.Items() { :Name = "Cornmeal", :Amount = 1, :TotalCost = 5.99 }
    }
  }
    </pre>

    <p>
      Note that we are using the <a href="http://lazygosu.org/misc.html">Object Initializer</a> syntax in gosu to declare
      this invoice.  This is a general feature of Gosu and is not specific to JSchema.
    </p>

    <p>
      As you can see readable and writable properties are created for each member in the JSchema document, making it easy
      to create an mutate JSchema-based objects.  As an example, let's add a new item to the invoice:
    </p>

    <pre>
  invoice.Items.add( new jschema.Invoice.Items() {  :Name = "Rice", :Quantity = 2, :TotalCost = 8.39 } )</pre>

    <p>And update the invoice ID:</p>

    <pre>
  invoice.Id = 43</pre>

    <h2>Serializing To JSON</h2>

    <p>You can write the JSchema object to a JSON string by calling the <code>write()</code> method:</p>

    <pre>
  print( invoice.write() )</pre>

    <p>Or, if you want nice whitespace in your JSON, use the <code>prettyPrint()</code> method, which has an optional indent argument:</p>

    <pre>
  print( invoice.prettyPrint() )
  print( invoice.prettyPrint(4) )</pre>

    <h2>Parsing From JSON</h2>

    <p>To parse JSON content, there are a set of static <code>parse()</code> methods on JSchema types:</p>

    <pre>
  var invoice = '{ "id" : 1 }' // A very boring invoice

  var invoice = Invoice.parse( str )

  print( "The ID of the Invoice is ${invoice.Id}" )
    </pre>

    <h2>Using HTTP</h2>

    <p>
      If you have a JSchema document that describes an http end point, you can easily do an HTTP Get or Post to retrieve
      the value of that document:
    </p>

    <pre>
  var invoiceViaGet = Invoice.get( "http://example.com/invoices", { "id" -> 42 } )

  var invoiceViaPost = Invoice.post( "http://example.com/invoices", { "id" -> 42 } )
    </pre>

    <p>
      Both methods allow you to pass arguments via a Map, which is an optional second argument.
    </p>

    <h2>Finding Things</h2>

    <p>JSchema does not have a JPath-like system and instead relies on programming languages to be good enough to
      make it pleasant to work with JSchema content.</p>

    <h3>Finding Everything</h3>

    <p>The <code>descendents()</code> method returns all nodes at or below the node it is invoked on.  This can be used
    to search the entire tree:
    </p>

    <pre>
  invoice.descendents().whereTypeIs(Invoice.Address)
                       .where( \ addr -> addr.State == "CA" )
                       .each( \ addr -> print( "Found CA Address : ${addr}" ) )
    </pre>

    <h3>Finding Specific Things</h3>

    <p>Finding all nodes of a specific type is a common operation, so there is a <code>find()</code> method that takes
    a specific type and returns all descendents (again, inclusive of the root node) of that type.  Using this method, the
    code above can be simplified to:</p>

    <pre>
  invoice.find(Invoice.Address)
         .where( \ addr -> addr.State == "CA" )
         .each( \ addr -> print( "Found CA Address : ${addr}" ) )
    </pre>

    <h3>Getting The Parent</h3>

    <p>JSchema-Gosu objects maintain pointer to their parent objects, which can be accessed via the <code>parent()</code> method:</p>

    <pre>
  invoice.find(Invoice.Address)
         .each( \ addr -> print( "Address Parent: ${addr.parent()}" ) )
    </pre>

    <p>The <code>parent()</code> method will be strongly typed where possible, so, for example, the return type of <code>parent()</code> on
    the <code>jschema.Invoice.Items</code> type is <code>jschema.Invoice</code>, since it is an inline type, whereas for
      <code>jschema.Invoice.Address</code> is it <code>Object</code>, since an Address can belong to multiple parents (i.e. both
    <code>jschema.Invoice</code> and <code>jschema.Invoice.Customers</code></p>

    <h2>Going Untyped</h2>

    <p>The JSchema-Gosu library inclues support for working with untyped JSON.  This functionality is outlined below.</p>

    <h3>Raw JSON Objects</h3>

    <p>JSchema-Gosu ships with a general JSON parser that returns objects from the model found in the
      <code>org.jschema.model</code> package.  This models is based on the Java Collections interfaces, <code>List</code> and
      <code>Map</code> in particular, but adds the concept of a parent pointer, effectively modeling the JSON tree.  Note this
      is in contrast to the standard JSON library, which does not implement the java Collections interfaces.</p>

    <p>The easiest way to parse raw JSON is the static method <code>org.jschema.util.JSchemaUtils.parseJsonObject()</code> which
      will return a <code>org.jschema.model.JsonMap</code>, which extends <code>Map&lt;String, Object&gt;</code>.  You
      can manipulate this object using the standard <code>java.util.Map</code> methods, such as <code>get()</code> and
      <code>put()</code>.</p>

    <p>In addition to the usual methods on <code>Map</code>, <code>JsonMap</code> also has:</p>
    <ul>
      <li><code>getMap(String name)</code> - returns the value cast to a JsonMap.</li>
      <li><code>getList(String name)</code> - returns the value cast to a JsonList.</li>
      <li><code>getString(String name)</code> - returns the value cast to a String.</li>
      <li><code>getNumber(String name)</code> - returns the value cast to a Number.</li>
      <li><code>getDecimal(String name)</code> - returns the value cast to a BigDecimal.</li>
      <li><code>getInt(String name)</code> - returns the value cast to a Long.</li>
      <li><code>getBoolean(String name)</code> - returns the value cast to a Boolean.</li>
      <li><code>write()</code> - returns a JSON serialized version of the object.</li>
      <li><code>prettyPrint()</code> - returns a JSON serialized version of the object with nice formatting.</li>
      <li><code>parent()</code> - returns the parent of this map.</li>
      <li><code>descendents()</code> - returns the descendents of this map.</li>
    </ul>

    <p><code>JsonList</code> has similar methods.</p>

    <h3>JSchema Objects Untyped</h3>

    <p>At runtime, JSchema-Gosu objects are actually simply <code>org.jschema.model.JsonMap</code>'s.  You can get at
    this underlying map for direct manipulation via the <code>asJSON</code> method:</p>

    <pre>
  var map = invoice.asJSON()

  print( "Raw ID: ${map.get("id")}" )
  map.put( "foo", "bar" ) // stash a non-schema based value away
    </pre>

    <p>Note that the keys of the map will be raw string values, and <em>may not</em> necessarily correspond to the
      property names (in fact often they will be different).</p>

    <p>It is obviously possible to subvert the type system in this manner, and store, say, a string where a boolean
    is expected, but we are all adults here, right?</p>

    <h2>Conversions</h2>

    <p>You can convert from one JSchema type to another using the <code>convertTo(Type)</code> method.  This will create
    a new object of the type passed in and fill in the properties of it based on the object that <code>convertTo()</code>
    was called on</p>
    
    <p>This only works if the type being converted to has a subset of the properties type being converted from.  Presently
    <code>convertTo()</code> will fail at runtime if this is not the case, but we intend to make it a compile time error.</p>

    <h2>JSON Types</h2>

    <p>A JSchema-based type can be derived from a sample JSON document.  Twitter, for example, offers an sample document
      from their User Timeline API here: https://dev.twitter.com/docs/api/1/get/statuses/user_timeline.</p>

    <p>If you download this sample to <code>src/jschema/TwitterUserTimeline.json</code>, you can write the following
      code:</p>

    <pre>
  var latestTweets = jschema.TwitterUserTimeline.get("http://api.twitter.com/1/statuses/user_timeline.json",
                                                     { "include_entities" -> true,
                                                       "include_rts" -> true,
                                                       "screen_name" -> "carson_gross",
                                                       "count"-> 5 } )
  for( tweet in latestTweets ) {
    print( tweet.Text )
  }
    </pre>

    <p>While certain type information is lost (e.g. enums are simply strings) it is still much more pleasant than the
    untyped alternative.</p>

    <h1>JSchema RPC Types</h1>


    <p>JSchema RPC types are defined in <code>jsc-rpc</code> files.  Given this JSchema RPC file at <code>src/rpc/EmployeeService</code>:</p>
    <pre>
  { "url" : "http://myserver:8080/employees",
    "description" : "Methods for manipulating employees",
    "typedefs@" : {
      "Employee" : {
        "first_name" : "string",
        "last_name" : "string",
        "age" : "int",
        "id" : "int"
      }
    }
    "functions" : [
      { "name" : "getEmployee",
        "description" : "Returns the employee of the given name",
        "args" : [ {"id" : "int" } ],
        "return_type" : "Employee"
      },
      { "name" : "updateEmployee",
        "description" : "Updates the given employee",
        "args" : [ { "employee", "Employee" } ],
        "return_type" : "boolean"
      }
    ]
  }
    </pre>
    <p>the following types are created</p>
    <ul>
      <li><code>rpc.EmployeeService</code> - The RPC type that you can invoke methods on.</li>
      <li><code>rpc.EmployeeService.CustomInstance</code> - A customized version of the endpoint (Can be used to change the URL hit, for example.)</li>
      <li><code>rpc.EmployeeService.Employee</code> - A JSchema type for the typedef.</li>
    </ul>
    <p>Given the JSchema RPC file above, you can write code like this:</p>
    <pre>
  var myEmp = EmployeeController.getEmployee(42)

  myEmp.Age++

  if( EmployeeController.updateEmployee(myEmp) ) {
    print( "Updated the age of ${myEmp.FirstName}")
  }
    </pre>
    <p>Where <code>emp</code> is the <code>Employee</code> JSchema type.</p>

    <h2>Customized Instances</h2>

    <p>If you want to change the behavior of an end point in the code, you can use the <code>with()</code> method.  As
    an example, if you wanted to change the URL that an RPC invocation will be done against, you could write this:</p>

    <pre>
  var customizedRPCService = EmployeeController.with( :url = "http://someotherserver/employees" )

  var myEmp = customizedRPCService.getEmployee(42)

  myEmp.Age++

  if( customizedRPCService.updateEmployee(myEmp) ) {
    print( "Updated the age of ${myEmp.FirstName}")
  }
    </pre>

    <h2>Global Defaults</h2>
    <p>You can set the Global Defaults for the RPC system using the <code>org.jschema.rpc.RPCDefaults</code> class.
    For example, to set the default request hander to be based on Apache HTTPClient (to enable HTTPS support, for example) you would do this:</p>

    <pre>
  org.jschema.rpc.RPCDefaults.setDefaultHandler(new org.jschema.rpc.ApacheHTTPClientCallHandler())
    </pre>
    <p>Note that the Apache HTTPClient jar does not come with the Goson library and will need to be included separately.</p>

    <h2>Publishing JSchema RPC Endpoints</h2>

    <p>You can easily publish JSchema RPC end points using the build in RPC server:</p>
    <pre>
  var server = new RPCServer()

  server.addEndPoint( new RPCEndPoint( EmployeeService, new EmployeeServiceImpl(), "/employees" ) )

  server.start()
    </pre>
    <p><code>EmployeeServiceImpl</code> is a Gosu class that implements the methods specified in the JSchema RPC file.
      Note that the methods are defined in terms of the JSchema RPC types, so both sides of the wire are using the same types.
    Thus there is no mapping or object serialization layer: that responsibility falls on the API publisher.</p>

    <h2>Publishing JSchema RPC Endpoints in Jetty/Tomcat</h2>

    <p>You can use <code>org.jschema.rpc.RPCFilter</code> to publish JSchema RPC Endpoints in a Servlet environment.</p>
    
    <p>The filter takes a single config parameter, <code>config</code>, which should be the neame of a class that implements
    <code>org.jschema.rpc.RPCFilter.Config</code> and has a default constructor.  This config object supplies the list
    of endpoints to the filter.</p>

  </body>
</html>